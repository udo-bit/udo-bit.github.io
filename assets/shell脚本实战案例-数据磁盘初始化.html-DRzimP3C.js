import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as a,d as e}from"./app-Dd2MQ5MX.js";const i={},l=e(`<h2 id="一、案例应用场景" tabindex="-1"><a class="header-anchor" href="#一、案例应用场景"><span>一、案例应用场景</span></a></h2><p>生产环境中的服务器一般会分为系统盘和数据盘两种磁盘，以dell R730举例，该服务器是一个2U的机架式服务器，满载可以挂载14块磁盘[2块在机箱内做系统盘，12块在面板做数据盘] ，我们一般的策略是系统盘做raid1，保障系统稳定性12块数据磁盘我们做raid10 或者 raid50，保障数据盘容错的同时还能做到优化IO的效果。</p><p>raid磁盘的容量是一定的，线上的数据又是不断增长的，也就是说总有一天会把你的数据磁盘填满，那怎么办？为了解决这个问题，人们想到了LVM[逻辑卷管理系统] ，当前数据盘容量不够用的时候，我们可以通过san存储获得网络磁盘，然后将该网络存储动态加入LVM中的卷组后就可以扩大LV了。整个过程采用在线扩容的方式，不会影响线上业务正是基于这个原因，我们又在系统中把raid数据盘在存数据之前做成了LVM磁盘，方便后续的扩容。</p><p>注意：有数据的磁盘不能再做LVM，因为需要格式化，数据会全部丢失。必须提前布局，否则就得提前准备跑路资金了。</p><h2 id="二、案例需求" tabindex="-1"><a class="header-anchor" href="#二、案例需求"><span>二、案例需求</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>给虚拟机添加一块磁盘(以sdb为例)，要求使用脚本对该磁盘分三个区：</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 1）主分区 /dev/sdb3 543M 文件系统 ext4 要求开机自动挂载到/data/data1目录</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 2) 逻辑分区 /dev/sdb5 2G</span></span>
<span class="line"><span></span></span>
<span class="line"><span> 3) 逻辑分区 /dev/sdb6 3G</span></span>
<span class="line"><span></span></span>
<span class="line"><span>使用/dev/sdb5 /dev/sdb6 新建卷组vg100，并创建一个PE为16M,容量为2.5G的逻辑卷lv100，</span></span>
<span class="line"><span>格式化为xfs,默认开机自动挂载到/data/data2目录</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="三、案例算法" tabindex="-1"><a class="header-anchor" href="#三、案例算法"><span>三、案例算法</span></a></h2><p>算法：完成一个任务的代码思路。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>脚本思路---算法</span></span>
<span class="line"><span>1、分区</span></span>
<span class="line"><span>2、创建逻辑卷</span></span>
<span class="line"><span>    2.1  创建物理卷</span></span>
<span class="line"><span>    2.2  创建卷组</span></span>
<span class="line"><span>    2.3  创建逻辑卷</span></span>
<span class="line"><span>3、格式化 /dev/sdb3   /dev/vg100/lv100</span></span>
<span class="line"><span>4、修改/etc/fstab文件</span></span>
<span class="line"><span>5、挂载分区</span></span>
<span class="line"><span>6、验证并输出挂载结果</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、代码实现" tabindex="-1"><a class="header-anchor" href="#四、代码实现"><span>四、代码实现</span></a></h2><p>代码实现的要点：要清楚每一步的步骤，不同的系统可能有细微的差别，一味的复制可不行的，需要提前手动做一下，把步骤捋清楚。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>实验代码    01_disk_partition.sh</span></span>
<span class="line"><span>#!/bin/bash</span></span>
<span class="line"><span># </span></span>
<span class="line"><span>#Author: Bai Shuming</span></span>
<span class="line"><span>#Created Time: 2019/11/1 21:05</span></span>
<span class="line"><span>#Release: </span></span>
<span class="line"><span>#Description:</span></span>
<span class="line"><span>#</span></span>
<span class="line"><span>#给虚拟机添加一块磁盘(以sdb为例)，要求使用脚本对该磁盘分三个区：</span></span>
<span class="line"><span>#  1）主分区 /dev/sdb3   543M   文件系统 ext4  要求开机自动挂载到/data/data1目录</span></span>
<span class="line"><span>#  2)   逻辑分区  /dev/sdb5   2G</span></span>
<span class="line"><span>#  3)   逻辑分区  /dev/sdb6   3G</span></span>
<span class="line"><span>#使用/dev/sdb5   /dev/sdb6   新建卷组vg100，并创建一个PE为16M,容量为2.5G的逻辑卷lv100，</span></span>
<span class="line"><span>#格式化为xfs,默认开机自动挂载到/data/data2目录</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#1、分区</span></span>
<span class="line"><span>fdisk /dev/sdb &lt;&lt;EOF</span></span>
<span class="line"><span>n</span></span>
<span class="line"><span>p</span></span>
<span class="line"><span>3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>+543M</span></span>
<span class="line"><span>n</span></span>
<span class="line"><span>e</span></span>
<span class="line"><span>4</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>+2G</span></span>
<span class="line"><span>n</span></span>
<span class="line"><span></span></span>
<span class="line"><span>+3G</span></span>
<span class="line"><span>w</span></span>
<span class="line"><span>EOF</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#2、创建逻辑卷</span></span>
<span class="line"><span>   #2.1 创建物理卷</span></span>
<span class="line"><span>    pvcreate /dev/sdb5 /dev/sdb6</span></span>
<span class="line"><span>   #2.2 创建卷组</span></span>
<span class="line"><span>    vgcreate -s 16M vg100 /dev/sdb{5..6}</span></span>
<span class="line"><span>   #2.3 创建逻辑卷</span></span>
<span class="line"><span>    lvcreate -L 2.5G -n lv100 vg100</span></span>
<span class="line"><span>#3、格式化</span></span>
<span class="line"><span>mkfs.ext4 /dev/sdb3</span></span>
<span class="line"><span>mkfs.xfs /dev/vg100/lv100</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#4、修改/etc/fstab,实现自动挂载</span></span>
<span class="line"><span>echo  &quot;/dev/sdb3   /data/data1 ext4  defaults   0 0&quot; &gt;&gt; /etc/fstab</span></span>
<span class="line"><span>echo &quot;/dev/vg100/lv100 /data/data2  xfs   defaults 0 0&quot; &gt;&gt; /etc/fstab</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#5、挂载分区</span></span>
<span class="line"><span>mkdir -p /data/data{1..2}</span></span>
<span class="line"><span>mount -a</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#6、验证并输出挂载结果</span></span>
<span class="line"><span>mount |grep &quot;/dev/sdb3&quot;</span></span>
<span class="line"><span>test $? -eq 0&amp;&amp;echo &quot;/dev/sdb3 挂载成功&quot; || echo &quot;/dev/sdb3挂载失败&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>##注意检索的时候，mount输出中LV的表示方式，或者直接检索挂载点/data/data2也可以。</span></span>
<span class="line"><span>mount |grep &quot;vg100-lv100&quot;</span></span>
<span class="line"><span>test $? -eq 0&amp;&amp;echo &quot;/dev/vg100/lv100 挂载成功&quot; || echo &quot;/dev/vg100/lv100挂载失败&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="五、实现验证" tabindex="-1"><a class="header-anchor" href="#五、实现验证"><span>五、实现验证</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>使用如下命令查看是否挂载成功</span></span>
<span class="line"><span>[root@zutuanxue ~]# df -Th</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,14),p=[l];function d(c,t){return a(),n("div",null,p)}const m=s(i,[["render",d],["__file","shell脚本实战案例-数据磁盘初始化.html.vue"]]),u=JSON.parse('{"path":"/demo/back-ends/Linux/Shell%E8%84%9A%E6%9C%AC/shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B-%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96.html","title":"shell脚本实战案例-数据磁盘初始化","lang":"en-US","frontmatter":{"title":"shell脚本实战案例-数据磁盘初始化","icon":"code","category":"shell","order":5,"description":"一、案例应用场景 生产环境中的服务器一般会分为系统盘和数据盘两种磁盘，以dell R730举例，该服务器是一个2U的机架式服务器，满载可以挂载14块磁盘[2块在机箱内做系统盘，12块在面板做数据盘] ，我们一般的策略是系统盘做raid1，保障系统稳定性12块数据磁盘我们做raid10 或者 raid50，保障数据盘容错的同时还能做到优化IO的效果。 r...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/demo/back-ends/Linux/Shell%E8%84%9A%E6%9C%AC/shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B-%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%E5%88%9D%E5%A7%8B%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"Utopia"}],["meta",{"property":"og:title","content":"shell脚本实战案例-数据磁盘初始化"}],["meta",{"property":"og:description","content":"一、案例应用场景 生产环境中的服务器一般会分为系统盘和数据盘两种磁盘，以dell R730举例，该服务器是一个2U的机架式服务器，满载可以挂载14块磁盘[2块在机箱内做系统盘，12块在面板做数据盘] ，我们一般的策略是系统盘做raid1，保障系统稳定性12块数据磁盘我们做raid10 或者 raid50，保障数据盘容错的同时还能做到优化IO的效果。 r..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-09-21T02:46:20.000Z"}],["meta",{"property":"article:author","content":"GXL"}],["meta",{"property":"article:modified_time","content":"2024-09-21T02:46:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"shell脚本实战案例-数据磁盘初始化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-21T02:46:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"GXL\\",\\"url\\":\\"https://www.cnblogs.com/feel-myself\\",\\"email\\":\\"gaoxiaoliang123@126.com\\"}]}"]]},"headers":[{"level":2,"title":"一、案例应用场景","slug":"一、案例应用场景","link":"#一、案例应用场景","children":[]},{"level":2,"title":"二、案例需求","slug":"二、案例需求","link":"#二、案例需求","children":[]},{"level":2,"title":"三、案例算法","slug":"三、案例算法","link":"#三、案例算法","children":[]},{"level":2,"title":"四、代码实现","slug":"四、代码实现","link":"#四、代码实现","children":[]},{"level":2,"title":"五、实现验证","slug":"五、实现验证","link":"#五、实现验证","children":[]}],"git":{"createdTime":1726886780000,"updatedTime":1726886780000,"contributors":[{"name":"udo-bit","email":"enote_gxl@163.com","commits":1}]},"readingTime":{"minutes":3.17,"words":952},"filePathRelative":"demo/back-ends/Linux/Shell脚本/shell脚本实战案例-数据磁盘初始化.md","localizedDate":"September 21, 2024","excerpt":"<h2>一、案例应用场景</h2>\\n<p>生产环境中的服务器一般会分为系统盘和数据盘两种磁盘，以dell\\nR730举例，该服务器是一个2U的机架式服务器，满载可以挂载14块磁盘[2块在机箱内做系统盘，12块在面板做数据盘]\\n，我们一般的策略是系统盘做raid1，保障系统稳定性12块数据磁盘我们做raid10 或者 raid50，保障数据盘容错的同时还能做到优化IO的效果。</p>\\n<p>raid磁盘的容量是一定的，线上的数据又是不断增长的，也就是说总有一天会把你的数据磁盘填满，那怎么办？为了解决这个问题，人们想到了LVM[逻辑卷管理系统]\\n，当前数据盘容量不够用的时候，我们可以通过san存储获得网络磁盘，然后将该网络存储动态加入LVM中的卷组后就可以扩大LV了。整个过程采用在线扩容的方式，不会影响线上业务正是基于这个原因，我们又在系统中把raid数据盘在存数据之前做成了LVM磁盘，方便后续的扩容。</p>","autoDesc":true}');export{m as comp,u as data};
